---
title: C++入门
comments: false
date: 2019-03-01 11:58:19
tags:
categories:
---

以上是摘要部分
<!--more-->

# C++类构造函数初始化列表

## 实例

```c++
class CExample {
    public:
        int a;
        float b;
        //构造函数初始化列表
        CExample(): a(0),b(8.8)
        {}
        //构造函数内部赋值
        CExample()
        {
            a=0;
            b=8.8;
        }
};
```

* 初始化和赋值对内置类型的成员没有什么大的区别，像上面的任一个构造函数都可以。
* 对非内置类型成员变量，为了避免两次构造，推荐使用类构造函数初始化列表。
* 但有的时候必须用带有初始化列表的构造函数：

> 1.成员类型是没有默认构造函数的类。若没有提供显示初始化式，则编译器隐式使用成员类型的默认构造函数，若类没有默认构造函数，则编译器尝试使用默认构造函数将会失败。
> 2.const成员或引用类型的成员。因为const对象或引用类型只能初始化，不能对他们赋值。 

* 初始化数据成员与对数据成员赋值的含义是什么？有什么区别？
* 首先把数据成员按类型分类并分情况说明:

> 1.内置数据类型，复合类型（指针，引用）
> 在成员初始化列表和构造函数体内进行，在性能和结果上都是一样的
> 2.用户定义类型（类类型）
> 结果上相同，但是性能上存在很大的差别。因为类类型的数据成员对象在进入函数体前已经构造完成，也就是说在成员初始化列表处进行构造对象的工作，调用构造函数，在进入函数体之后，进行的是对已经构造好的类对象的赋值，又调用个拷贝赋值操作符才能完成（如果并未提供，则使用编译器提供的默认按成员赋值行为）

初始化列表的成员初始化顺序

> C++初始化类成员时，是按照声明的顺序初始化的，而不是按照出现在初始化列表中的顺序。

有两种方法避免它的不可预测的值：

* 一个是总是按照你希望它们被初始化的顺序声明成员
* 第二个是，如果你决定使用初始化列表，总是按照它们声明的顺序罗列这些成员。这将有助于消除混淆。