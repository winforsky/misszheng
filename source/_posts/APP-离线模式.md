---
title: APP 离线模式
comments: false
date: 2019-01-15 17:13:22
tags:
categories:
---

APP支持离线模式不仅能给用户带来更好的体验，还是部分用户期望的功能。
有许多不同的方法可以使得APP支持离线模式，但每个方法都有其优点和缺点。
没有一个银弹能满足所有的使用场景，所以，你需要根据自己的需要选择合适的方法，或许是多个方法的结合。
主要的解决方法有四种：

1）使用数据库，如CoreData 或 Realm 

2）使用非格式化缓存，如 PINCache 或 NSURLCache

3）使用统一模型缓存，如Rocket Data

4）使用文件系统缓存
<!--more-->

# 为什么要离线模式
* 速度优先。当页面的加载时间超过3秒时，超过40%的用户会选择放弃等待离开APP。 用户希望能够APP能够快速响应。如果APP支持离线模式，在弱网络的情况下也能快速响应。

* 离线需求大。有统计显示：超过15%的APP使用时间是在无网络的情况下。甚至有些用户时常处于有网络和无网络不停变化的情况。如果一个APP无法在这种环境下使用，用户便会停止使用这个APP转而使用其他APP。

# 缓存Cache 和 数据库Database
当讨论实现离线模式的解决方案时，第一步就是要决定是使用缓存Cache还是使用数据库Database。

虽然数据库的功能很强大，但它正在被开发者过度使用。

有些时候，对于某些APP来说，使用缓存是一种更简单甚至更合适的解决方案。

虽然很多人喜欢直接使用SQLite，但最通用的数据库解决方案是使用Core Data 或 Realm。你定义数据模型，从网络加载数据，然后存储到数据库中。之后，视图控制器UIViewController只要监听数据库的查询语句，当数据发生变化时更新视图控制器。

使用缓存时，从缓存中加载数据和从网络获取数据是同时进行。缓存数据不强制要求结构化，可以是网络数据的简单序列化。从代码角度上看，从缓存加载数据和从网络加载数据是无区别。有很多开源的缓存实现第三方库， PINCache 和 NSURLCache 是两个通用选择。

## 以下场景适合使用数据库：
1）你能够下载用户的所有数据，并在占用磁盘空间不多的前提下存储。

2）你能够容易写出限制数据在设备上的使用逻辑。

3）你需要简单实现在大量数据上的本地搜索功能。

## 以下场景适合使用缓存：
1）你不能下载用户的所有数据，同时数据需要一个简单的过期策略。

2）你已经实现了从网络获取数据的逻辑，需要在不重写APP的情况下添加离线模式。

3）你需要一个简单的、轻量的、灵活的解决方法。

## 使用数据库时可能存在的问题：
1）很难保证数据的正确性，数据库的诟病。你需要提前考虑到：在以后的app中可能会花费不少的时间来处理因此导致的崩溃问题。

2）无论什么时候当外界数据定义发生变化时，需要重写数据模型并迁移数据。

3）希望通过删除数据来释放空间时很难的，因为APP不能明确告诉你哪些数据正在使用。

对于一些APP，忽略数据库的缺点和过度使用的情况下，使用数据库时个不错的选择。
举例来说，Podcast播放器适合使用数据库。
你可以下载相当数量的即将上映的剧集，同时你也很容易知道什么时候删除数据，比如用户播放完成一集之后删除。
此外，游戏也适合使用数据库，用户不希望已经保存好的游戏被删除，除非用户自己手动删除。

另一方面，社交媒体类APP更适合使用缓存。因为你不可能下载用户的所有数据，而且，数据库会变得越来越大。同理，新闻媒体类APP也适合使用缓存。因为用户浏览新文章时，数据库不会停止增长。同时，缓存很容易存储用户读过的文章并自动删除旧的文章。此外，你不需要迁移数据模型或担心数据错误。


# 格式化数据 和 非格式化数据
在缓存中存储数据的方法主要有使用格式化数据存储和使用非格式化数据存储两种。从可视化上看，大多数APP的数据是树形结构。它有一个根节点和一些子节点。当缓存数据时，你可以简单地把整个树作为一个整体进行存储。

这是使用缓存的最简单方法，你通过少量的代码就能实现它，你也很容易取出一个唯一id来代表一个对象，比如说你可以使用url作为唯一id来存储对应的数据。

然而，你也会注意到内嵌的author对象2次被存储到缓存中。这意味着，如果你更新编号id=3的文章article的作者author后，下一次你获取编号id=4的文章时，你获取到文章article的作者author依然时旧的作者。

如果这种数据保持一致性很重要的话，你需要考虑子缓存数据之前先格式化数据。
这意味着需要把树形结构拆解到子数据模型中，同时使用唯一id来缓存每个数据模型。

注意：这里并不是说数据库。这里的每个数据条目仍然是由id键控制的非结构化数据的blob。这意味着当外界的数据模型发生变化时你仍然不需要迁移数据模型，过期数据也很简单。

然而，要实现这个结构化数据并不简单，你需要编写重构数据模型和每个数据模型具有唯一id的逻辑。

[The Many Offline Options for iOS Apps](https://medium.com/device-blogs/the-many-offline-options-for-ios-apps-2922c9b3bff3)

```
I’ve previously written about using this strategy for the LinkedIn App, and the code that powers consistency amongst models is open-source. Using this solution, adding offline behavior was easy for new pages, and we never had to migrate models or clean up large databases.
```

# 从服务器获取数据
有很多种从网络、缓存或数据库中获取数据的方法。

最简单的方法时同时从缓存和网络获取数据。如果先返回缓存数据，则使用缓存数据完成，之后一旦网络数据返回，则使用心获取到的网络数据来进行更新。这允许你在网络层完成大部分的缓存逻辑，视图UIViewClontroller只需要完成显示数据即可。

但是这种解决方法有时会执行完成2次。对于某些APP来说，这样做或许时有问题的，因此你需要考虑在网络失败、网络慢或网络耗时太长的情况下，APP仅仅显示缓存数据。建议网络请求超时时间设置短点。当离线时，网络请求超时需要一分钟之后才会返回，而不是立即作为错误返回。

另外一种解决方法时把缓存和数据库放置在UIViewController和网络层之间。这种“reactive”模式，你可以立即从数据库获取到数据和监听到数据的变化。一旦网络请求完成，它会更新数据库，这样UIViewController会自动更新。这个做法已经有很好的文档实现，参见[how-to-design-offline-first-approach-in-mobile-app](https://www.netguru.com/blog/how-to-design-offline-first-approach-in-mobile-app)。虽然这是一种实现，但这种实现需要所有的UIViewController都去监听数据的改变，这有时不大容易实现，而且容易产生大量的重复代码。

最后你可以使用数据库同步解决方案，比如使用Realm Platform 或 Firebase。使用这些平台，你在服务器上持有数据库的版本号，当数据发生改变时自动同步有效数据到客户端。这种解决方法实现比较复杂，但是它的复杂性被隐藏起来，也不要求你如何在服务器端定义你的数据结构。

# 上传数据
当用户在APP中改变了数据的时候，很难决定在低网络连接情况下应该如何工作。最简单的方法是显示一个转轮并等待请求完成。您可以阻塞UI，并在必要时用横幅或警告提示用户失败了。但是这不是最好的用户体验。我仍然无法相信iMessage不允许我离线发送消息。

这个问题的一个常见解决方案是为离线任务创建一个队列。如果一个网络请求由于网络的低连接性而失败时，将它添加到离线任务支持的队列中，并在连接到internet时重试。这在理论上听起来很简单，但在实践中，仍然有很多边缘情况需要考虑:

1.请求应该重试多少次？

2.请求的顺序性是否重要？

3.如果一个请求多次请求后最终还是失败，要如何通知用户？

4.是否需要让用户知道正在重试网络请求和没有同步完成请求？

上面提及的内容中最重要的是，如果上传失败，您需要恢复数据。

考虑以下流程：

1.用户在手机离线状态下喜欢了某项数据

2.用户在笔记本在线状态下喜欢了同样的某项数据

3.手机连接到网络并下载同样的某项数据的最新状态

4.用户在手机上因为某些原因导致上传这个喜欢失败

5.手机恢复某些数据为不喜欢的状态

注意到上面的操作结束时手机上某项数据的状态时是错误的。更糟糕的是，因为用户并不知道手机上的状态不对，他也许不会再从网络刷新这个数据。当恢复数据时，你不能简单的使用这个动作的对立状态，而是恢复到最后一次服务器返回的正确数据。这意味着你需要同时存储本地当前状态和服务器最后返回的状态。

对于你的应用程序，你不需要实现一个修改器队列。上传数据是困难的，此时，您应该仔细考虑哪些用例是您最关心的，并将精力集中在那些优秀的体验上。

## 相关说明
一旦在本地编辑缓存或数据库之后，你可能需要更新应用程序中的多个界面。这是一个深刻的话题，超出了本文的范围，但这里有一些技巧需要考虑:

* 监听数据库的变化`Listening to Database Changes`

大多数数据库都提供了侦听模型更改的功能。如果您使用的是数据库而不是缓存，这可能是最简单的解决方案。

* 代理`Delegation`

如果更改只影响应用程序中相关联的几个视图控制器，则可以简单地使用委托来传播更改。有些时候，数据的这些改变并没有出现在其他地方，此时，你可以使用这个代理方式。虽然这是一个非常简单的解决方案，但如果它能够正常工作，你就不应该忽略它。

* 事件总线`An Event Bus`

实现缓存更改的最简单方法之一是使用事件总线系统通知所有侦听器更改。您只需侦听对某个id的更改，如果它发生更改，则从缓存重新加载数据并刷新视图。`NSNotificationCenter`是第一个第三方解决方案，但我建议查看一些提供更好的API和类型安全通知的开源项目。`SwiftNotificationCenter`和`SwiftEventBus`是两个流行的示例。

* Rocket Data

Rocket Data管理不可变模型的一致性，并专门设计用于与缓存良好地协作。它只是侦听特定id上的更改，并在模型发生更改时通知您。它是比事件总线更强大的解决方案，允许您使用不可变的模型，但也需要更多的工作来设置它。有关更多信息，请参见Rocket Data或Rocket Data的帮助文档。

# 混合应用
我最近在我的象棋战术应用程序中添加了离线模式。我有三个用于离线使用的用例，每个用例的需求略有不同:

1）如果用户最近访问过应用程序中的所有页面，那么他们应该能够离线查看这些页面。

2）用户应该能够显式保存谜题以离线查看，这些永远不应该被删除。

3）该应用程序的主要功能是根据用户的技能水平为他们提供一个随机的谜题，这应该离线工作。

基于以上所有这些用例考虑，我决定选择三种不同的离线技术，而不是选择一种离线技术!

为了能够查看任意页面，我简单地添加了一个键值存储缓存，用URL作为键值来缓存对应的URL请求。

我选择了一个非规范化的缓存，因为我的请求中没有太多的子模型，而子模型的一致性对我的应用程序并不重要。尽管我已经编写了整个应用程序，但添加这些代码很简单，只花了几个小时。

为了保存智力游戏数据，我使用了结构化数据库。我不希望这些数据被删除，而且用户也不可能保存太多数据，因为单个智力游戏数据只有几KB。结构化数据库还允许将来对这些智力游戏数据进行排序或筛选。

为了向用户展示一局随机的智力游戏，我也使用了一个数据库，但是没有使用结构化数据库，我只是使用了一个NSData blob来存储JSON。

在后台，该应用程序下载了大约200个智利游戏并将其存储起来。如果用户离线，应用程序会随机选择一个【这个操作和缓存有点区别】，将其呈现给用户，然后删除它。使用数据库符合我的需要，因为我可以轻松地控制它的大小。将数据存储为blob而不是使用单独的字段允许我简化代码并避免任何额外的解析逻辑。与流行的观点相反，在数据库中以blob形式存储数据非常快，[只要blob很小](https://www.sqlite.org/fasterthanfs.html)。

在离线选择随机拼图时，我的视图控制器从不直接使用数据库模型。相反，在将数据blob传递给视图控制器之前，我将其解析为内存模型。这样，我的视图控制器与任何磁盘存储逻辑完全隔离，我可以在任何时候安全地删除这些模型。

对于上传数据，我实现了一个简单的队列来上传用户的评级更改。由于这个应用程序的阅读量很大，我认为不值得实现其他POST请求。这款应用程序只显示一条消息:“你的评级将在你在线时更新。”

这里的关键点是:您不应该强制每个特性使用相同的离线解决方案。通过结合不同的技术，您可以提供更好的用户体验并减少开发时间。

# 总结
如果没有其他问题，我希望您记住，让应用程序离线工作有许多不同的解决方案。不要因为你熟悉核心数据实现，就马上开始对它大动脑筋;在选择最佳解决方案之前，请仔细考虑您要解决的问题。

对于许多应用程序来说，缓存是更好的选择，因为它是一个更简单的解决方案。它提供了一种简单的回收方法，不需要模型迁移，而且不会一直崩溃。

不管你选择的技术是什么，你也需要考虑如何上传更改，并使你的应用程序作为离线策略的一部分保持一致。最后，你不应该把自己局限于一种技术。通常，结合不同的技术将是最好的解决方案。

# 额外说明
* 数据应该保存在哪里Where should you save data?

iOS实际上提供了一个缓存目录来存储缓存数据。但是，如果设备空间不足，则清除此目录。如果它实际上是一个缓存，这是一件很好的事情，但如果您的基本功能依赖于此数据，则不是这样。您还可以将文件放在tmp文件夹中，以保存更短的文件。

* iOS的离线检测非常脆弱Offline Detection on iOS is very Flaky

苹果提供了一个可达性API，当与互联网的连接发生某种变化时，它会通知你。然而，这个API很不稳定，您不应该依赖它作为基础架构逻辑。在内部，它实际上从不发出网络请求。它只是告诉你硬件什么时候可以连接到互联网。您可以使用这个API向用户显示UI，但是您永远不应该因为这个API而避免发送请求——了解您是否能够真正到达服务器的唯一方法是尝试该请求，更详细的参见[til-boy-have-i-been-misusing](http://blog.jaredsinclair.com/post/179083065595/til-boy-have-i-been-misusing)。

* 规范化缓存不会使用更少的数据Normalized Caches Don’t Use Less Data

正如我前面提到的，规范化缓存并不一定比非规范化缓存使用更少的数据。虽然它们不复制模型，但是单独存储数据是有开销的。考虑下面这个简单的例子:
```
// Denormalized data
{ id: 'parent', child: { id: 'child' }}
// Normalized data
{ id: 'parent', child: 'child' }
{ id: 'child' }
```
注意，在第二个示例中，子模型的id是重复的，这意味着这个实例中的规范化数据使用的总字节实际上更高。这看起来很小，但是如果您有很多小的、嵌套的模型，那么它的累积速度会非常快。在使用LinkedIn应用程序时，我们发现规范化数据比非规范化数据多占用5-10%的空间。正因为如此，我们决定通过网络发送非规范化的数据，其中大小很重要。

当然，这取决于您的特定数据集。这里有一个权衡，所以在你决定之前先衡量一下!

* 最快的缓存是SQLite!?The Fastest Cache is SQLite!?

讽刺的是，我发现iOS开发中可用的最快缓存实际上是SQLite。您可以简单地创建一个包含三个字段的模型:id、数据和时间戳。在id上创建索引之后，查找和存储比许多开源解决方案使用的NSFileManager解决方案要快。

原文来自：(The Many Offline Options for iOS Apps)[https://medium.com/device-blogs/the-many-offline-options-for-ios-apps-2922c9b3bff3)