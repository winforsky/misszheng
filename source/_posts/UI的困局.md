---
title: UI的困局
comments: false
date: 2019-03-12 10:29:24
tags:
categories:
---

以上是摘要部分
<!--more-->

# 性能的问题

客户端的性能问题大多是阻塞主线程导致用户的交互反馈出现可以感知的延迟。
详细说起来，大体有三种原因：
> UI 渲染需要时间较长，无法按时提交结果；
> 一些需要密集计算的处理放在了主线程中执行，导致主线程被阻塞，无法渲染 UI 界面；
> 网络请求由于网络状态的问题响应较慢，UI 层由于没有模型返回无法渲染。
上面的这些问题都会影响应用的性能，最常见的表现就是 UITableView 在滑动时没有达到 60 FPS，用户能感受到明显的卡顿。

## 屏幕渲染FPS

屏幕的渲染可能要从 CRT（Cathode ray tube） 显示器和 LCD（Liquid-crystal display） 显示器讲起。

CRT 显示器是比较古老的技术，它使用阴极电子枪发射电子，在阴极高压的作用下，电子由电子枪射向荧光屏，使荧光粉发光，将图像显示在屏幕上，这也就是用磁铁靠近一些老式电视机的屏幕会让它们变色的原因。

FPS 就是 CRT 显示器的刷新频率，电子枪每秒会对显示器上内容进行 60 - 100 次的刷新，哪怕在我们看来没有任何改变。

但是 LCD 的原理与 CRT 非常不同，LCD 的成像原理跟光学有关：
> 在不加电压下，光线会沿着液晶分子的间隙前进旋转 90°，所以光可以通过；
> 在加入电压之后，光沿着液晶分子的间隙直线前进，被滤光板挡住。

如果你可以翻墙，相信[这个视频会更好得帮助你理解 LCD 的工作原理](https://www.youtube.com/watch?v=Bf3547WB5qs)

LCD 的成像原理虽然与 CRT 截然不同，每一个像素的颜色可以在需要改变时才去改变电压，也就是不需要刷新频率，
但是由于一些历史原因，LCD 仍然需要按照一定的刷新频率向 GPU 获取新的图像用于显示。

## 屏幕的数据来源GPU

但是显示器只是用于将图像显示在屏幕上，谁又是图像的提供者呢？图像都是我们经常说的 GPU 提供的。

而这导致了另一个问题，由于 GPU 生成图像的频率与显示器刷新的频率是不相关的，那么在显示器刷新时，GPU 没有准备好需要显示的图像怎么办；或者 GPU 的渲染速度过快，显示器来不及刷新，GPU 就已经开始渲染下一帧图像又该如何处理？

如果解决不了这两个问题，就会出现上图中的屏幕撕裂（Screen Tearing）现象，屏幕中一部分显示的是上一帧的内容，另一部分显示的是下一帧的内容。

我们用两个例子来说明可能出现屏幕撕裂的两种情况：

> 如果显示器的刷新频率为 75 Hz，GPU 的渲染速度为 100 Hz，那么在两次屏幕刷新的间隔中，GPU 会渲染 4/3 个帧，后面的 1/3 帧会覆盖已经渲染好的帧栈，最终会导致屏幕在 1/3 或者 2/3 的位置出现屏幕撕裂效果；
> 那么 GPU 的渲染速度小于显示器呢，比如说 50 Hz，那么在两次屏幕刷新的间隔中，GPU 只会渲染 2/3 帧，剩下的 1/3 会来自上一帧，与上面的结果完全相同，在同样的位置出现撕裂效果。

到这里，有人会说，如果显示器的刷新频率与 GPU 的渲染速度完全相同，应该就会解决屏幕撕裂的问题了吧？
其实并不是。显示器从 GPU 拷贝帧的过程依然需要消耗一定的时间，如果屏幕在拷贝图像时刷新，仍然会导致屏幕撕裂问题。

## 多个缓冲区

引入多个缓冲区可以有效地缓解屏幕撕裂，也就是同时使用一个帧缓冲区（frame buffer）和多个后备缓冲区（back buffer）；在每次显示器请求内容时，都会从帧缓冲区中取出图像然后渲染。

虽然缓冲区可以减缓这些问题，但是却不能解决；如果后备缓冲区绘制完成，而帧缓冲区的图像没有被渲染，后备缓冲区中的图像就会覆盖帧缓冲区，仍然会导致屏幕撕裂。

解决这个问题需要另一个机制的帮助，也就是垂直同步（Vertical synchronization），简称 V-Sync 来解决。

## V-Sync

V-Sync 的主要作用就是保证只有在帧缓冲区中的图像被渲染之后，后备缓冲区中的内容才可以被拷贝到帧缓冲区中，理想情况下的 V-Sync 会按这种方式工作：

每次 V-Sync 发生时，CPU 以及 GPU 都已经完成了对图像的处理以及绘制，显示器可以直接拿到缓冲区中的帧。但是，如果 CPU 或者 GPU 的处理需要的时间较长，就会发生掉帧的问题：

在 V-Sync 信号发出时，CPU 和 GPU 并没有准备好需要渲染的帧，显示器就会继续使用当前帧，这就加剧了屏幕的显示问题，而每秒显示的帧数会少于 60。

由于会发生很多次掉帧，在开启了 V-Sync 后，40 ~ 50 FPS 的渲染频率意味着显示器输出的画面帧率会从 60 FPS 急剧下降到 30 FPS，原因在这里不会解释，读者可以自行思考。

其实到这里关于屏幕渲染的内容就已经差不多结束了，根据 V-Sync 的原理，优化应用性能、提高 App 的 FPS 就可以从两个方面来入手，优化 CPU 以及 GPU 的处理时间。

性能调优的策略
CPU 和 GPU 在每次 V-Sync 时间点到达之前都在干什么？如果，我们知道了它们各自负责的工作，通过优化代码就可以提升性能。

很多 CPU 的操作都会延迟 GPU 开始渲染的时间：

布局的计算 - 如果你的视图层级太过于复杂，或者视图需要重复多次进行布局，尤其是在使用 Auto Layout 进行自动布局时，对性能影响尤为严重；
视图的惰性加载 - 在 iOS 中只有当视图控制器的视图显示到屏幕时才会加载；
解压图片 - iOS 通常会在真正绘制时才会解码图片，对于一个较大的图片，无论是直接或间接使用 UIImageView 或者绘制到 Core Graphics 中，都需要对图片进行解压；
…
宽泛的说，大多数的 CALayer 的属性都是由 GPU 来绘制的，比如图片的圆角、变换、应用纹理；但是过多的几何结构、重绘、离屏绘制（Offscrren）以及过大的图片都会导致 GPU 的性能明显降低。

## AsyncDisplayKit

ASDK 从开发到开源大约经历了一年多的时间，它其实并不是一个简单的框架，更像是对 UIKit 的重新实现，把整个 UIKit 以及 CALayer 层封装成一个一个 Node，将昂贵的渲染、图片解码、布局以及其它 UI 操作移出主线程，这样主线程就可以对用户的操作及时做出反应。

在 ASDK 中最基本的单位就是 ASDisplayNode，每一个 node 都是对 UIView 以及 CALayer 的抽象。但是与 UIView 不同的是，ASDisplayNode 是线程安全的，它可以在后台线程中完成初始化以及配置工作。

如果按照 60 FPS 的刷新频率来计算，每一帧的渲染时间只有 16ms，在 16ms 的时间内要完成对 UIView 的创建、布局、绘制以及渲染，CPU 和 GPU 面临着巨大的压力。

但是从 A5 处理器之后，多核的设备成为了主流，原有的将所有操作放入主线程的实践已经不能适应复杂的 UI 界面，所以 ASDK 将耗时的 CPU 操作以及 GPU 渲染纹理（Texture）的过程全部放入后台进程，使主线程能够快速响应用户操作。

ASDK 通过独特的渲染技巧、代替 AutoLayout 的布局系统、智能的预加载方式等模块来实现对 App 性能的优化。

### ASDK 的渲染过程

ASDK 中到底使用了哪些方法来对视图进行渲染呢？本文主要会从渲染的过程开始分析，了解 ASDK 底层如何提升界面的渲染性能。

在 ASDK 中的渲染围绕 ASDisplayNode 进行，其过程总共有四条主线：
1)初始化 ASDisplayNode 对应的 UIView 或者 CALayer；
2)在当前视图进入视图层级时执行 setNeedsDisplay；
3)display 方法执行时，向后台线程派发绘制事务；
4)注册成为 RunLoop 观察者，在每个 RunLoop 结束时回调。

因为 UIView 和 CALayer 虽然都可以用于展示内容，不过由于 UIView 可以用于处理用户的交互，所以如果不需要使用 UIView 的特性，直接使用 CALayer 进行渲染，能够节省大量的渲染时间。

## AutoLayout自动布局

iOS 中视图所需要的布局信息只有两个，分别是 origin/center 和 size，在这里我们以 origin & size 为例，也就是 frame 时代下布局的需要的两个信息；这两个信息由四部分组成：
x & y
width & height

以左上角的 (0, 0) 为坐标的原点，找到坐标 (x, y)，然后绘制一个大小为 (width, height) 的矩形，这样就完成了一个最简单的布局。而 Auto Layout 的布局方式与上面所说的 frame 有些不同，frame 表示与父视图之间的绝对距离，但是 Auto Layout 中大部分的约束都是描述性的，表示视图间相对距离，以上图为例：
A.left = Superview.left + 50
A.top  = Superview.top + 30
A.width  = 100
A.height = 100

B.left = (A.left + A.width)/(A.right) + 30
B.top  = A.top
B.width  = A.width
B.height = A.height
虽然上面的约束很好的表示了各个视图之间的关系，但是 Auto Layout 实际上并没有改变原有的 Hard-Coded 形式的布局方式，只是将原有没有太多意义的 (x, y) 值，变成了描述性的代码。

我们仍然需要知道布局信息所需要的四部分 x、y、width 以及 height。换句话说，我们要求解上述的八元一次方程组，将每个视图所需要的信息解出来；Cocoa 会在运行时求解上述的方程组，最终使用 frame 来绘制视图。

重点是：采用自动布局之后需要复杂的运算才能得到需要的x、y、width、height，之后才能真正布局。

Auto Layout 的原理其实就是对 Cassowary 算法的一种实现，就是对线性方程组或者不等式的求解。

render loop
render loop 是一个每秒钟跑120次的一个进程，是为了确保所有的内容都能为每一个frame做好准备。render loop 一共包括三个步骤来更新约束，布局和渲染。

首先，每一个需要接收到更新约束的view会从子view向上传递，直到window
然后，每一个接收到的view开始layoutsubviews，和更新约束是从相反的方向开始，layout从window开始到每一个子view进行layout。
最后，每一个需要渲染的view，和layout相同，从父view向子view开始渲染。

通过instrument调试工具，可以看出一些布局上的耗时问题。一下是需要注意的几点：
减少布局的视图数量
避免删除所有的约束的情况
对于静态约束，只需要添加一次
只改变需要改变的约束
尽量用hide() 方法隐藏view，而不是remove然后在add

引用来源
[iOS 保持界面流畅的技巧](https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/)
[CPU VS GPU](https://zsisme.gitbooks.io/ios-/content/chapter12/cpu-versus-gpu.html)
[使用 ASDK 性能调优 - 提升 iOS 界面的渲染性能](https://draveness.me/asdk-rendering)