一. 面试原则

二. 面试题
    a）计算机基础
      1. 线程，进程
      2. 网络协议.
      3. 简单算法.
      4. 安全方面.
      5. 等等.
         
    b)  Objective - C基础
      1.  如何在不改变属性值的情况下触发 KVO.
当观察某对象 A 时，KVO 机制动态创建一个对象A当前类的子类，并为这个新的子类重写了被观察属性 keyPath 的 setter 方法。setter 方法随后负责通知观察对象属性的改变状况。
Apple 使用了 isa 混写（isa-swizzling）来实现 KVO 。
当观察对象A时，KVO机制动态创建一个新的名为：NSKVONotifying_A 的新类，该类继承自对象A的本类，且 KVO 为 NSKVONotifying_A 重写观察属性的 setter 方法，setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象属性值的更改情况。
修改
使用方法,可实现取消系统kvo，自己触发，也就可控。

+(BOOL)automaticallyNotifiesObserversForKey:(NSString *)key{
    if ([key isEqualToString:@"name"]) {
        return NO;
    }else{
        return [super automaticallyNotifiesObserversForKey:key];
    }
}
-(void)setName:(NSString *)name{
    
    if (_name!=name) {
        
        [self willChangeValueForKey:@"name"];
        _name=name;
        [self didChangeValueForKey:@"name"];
    }
      
}

      2.  如何避免触发 KVO.

      3.  如何对NSMutableArray进行 KVO 监听.
对于 NSMutableArray 内容的变化进行观察，是我们比较常见的一个需求。但是在调用它的 addObject、removeObject 系列方法时，并不会触发它自己的 set 方法。所以，对一个可变数组进行观察，在它加减元素时不会收到期望的消息。

那么，该如何实现对 NSMutableArray 的 KVO 呢？官方为我们提供了这个方法- (NSMutableArray *)mutableArrayValueForKey:(NSString *)key

像之前一样，为可变数组添加 KVO。在加减元素时，使用这个方法来获取我们要进行操作的可变数组，便可以像普通的属性一样，收到它变化的消息。

举个例子，myItems 是我们要进行 KVO 的一个属性，它的定义如下：

@property (nonatomic, strong) NSMutableArray *myItems;

在它进行添加元素时，使用如下方法：

[[self mutableArrayValueForKey:@"myItems"] addObject:item];
这样，我们便实现了对 NSMutableArray 的 KVO。在加减元素时，使用这个方法来获取我们要进行操作的可变数组，便可以像普通的属性一样，收到它变化的消息。

      4.  KVO与KVC什么关系.
KVC : 键值编码，是Key Value Coding 的简称，cocoa的标准组成部分，是一种可以直接通过字符串的名字(Key)来访问类属性的机制，而不是通过调用Setter方法、Getter方法进行访问。KVC是一个用于间接访问对象属性的机制（只是通过字符串访问，而不是访问器方法去访问一个对象实例变量的机制），使用该机制不需要调用set或get方法和“->”方法访问成员变量，而是通过setValue:forKey: 和 valueForKey:方法进行成员变量的访问，将在内部查找名为_key或key的成员变量，如果找不到，就会报错。KVC的使用环境：无论是property还是普通的全局属性变量，都可以使用KVC；KVC优点：1.主要的好处就是减少代码量；2.没有property的变量（即：私有变量private）也能通过KVC进行设置。KVC缺点：如果key只写错，编写的时候不会报错，但是运行的时候会报错；KVO : 键值监听，是Key Value ObserVing 的简称，当指定对象的属性被修改之后，允许对象接收到通知的机制。KVO：是一个对象能够观察另外一个对象的属性的值，并且能够发现值得变化。KVO适合一个任意类型的对象对另外的对象进行监听，当被监听的对象一旦发生改变，观察者马上做出反应。但是也只能对属性作出反应，而不会对方法或动作作出反应。
KVO优点：
1.能够提供一种简单的方法实现两个对象的同步；
2、能够对内部对象的状态改变作出响应，而且不需要改变内部对象的实现；
3.能够提供被观察者属性的最新值和之前的值；
4.使用key Path来观察属性，因此可以观察嵌套对象；
5.完成了对观察对象的抽象，因为不需要额外的代码来允许观察者被观察。

KVO缺点：
1.我们观察的属性必须使用strings定义，编译时不会出现警告；
2.对属性重构，将导致观察代码不可用；
3.复杂的 “if” 语句要求对象正在观察多个值，是因为所有的观察代码通过一个方法来指向；
4.当释放观察者的时候不需要移除观察者。

      5.  写在扩展里面的属性会触发KVO么.
在Category 中仅仅是对相应属性做了一个getter与setter方法的声明,没有自动生成具体方法的实现与没有自动生成对应的成员变量。
换句话来说，在class中都是会自动生成的。
如果想要在分类中添加成员变量，是不能像class中那么简单的添加， 需要借助runtime机制。
objc_setAssociatedObject 和 objc_getAssociatedObject

      6.  同时对 一个对象的多个属性进行 KVO监听，运行时会创建几个子类, 为什么.如果是一个子类，根据什么判断已经创建过子类了.

1.使用runtime动态生成一个子类 NSKVONotifying_xxxxx ，并让instance对象的isa指向这个全新的子类。
2.该子类重写了父类的setter方法,当修改instance对象的属性时，会调用Foundation框架的 _NSSetXXXXValueAndNotify() 函数，该函数内部做了以下操作
2-1.调用 willChangeValueForKey:
2-2 调用父类的 setter方法
2-3 调用 didChangeValueForKey: ✅ 
2-3-1：didChangeValueForKey  ✅方法内部会触发监听器的(observer) 监听方法( observeValueForKeyPath:ofObject:change:context)
2.手动触发KVO？

手动调用 这两个方法
willChangeValueForKey: ✅
didChangeValueForKey: ✅
系统实现KVO有以下几个步骤：

当类A的对象第一次被观察的时候，系统会在运行期动态创建类A的派生类。我们称为B。
在派生类B中重写类A的setter方法，B类在被重写的setter方法中实现通知机制。
类B重写会 class方法，将自己伪装成类A。类B还会重写dealloc方法释放资源。 系统将所有指向类A对象的isa指针指向类B的对象。

KVO同KVC一样，通过 isa-swizzling 技术来实现。当观察者被注册为一个对象的属性的观察对象的isa指针被修改，指向一个中间类，而不是在真实的类。其结果是，isa指针的值并不一定反映实例的实际类。 所以不能依靠isa指针来确定对象是否是一个类的成员。应该使用class方法来确定对象实例的类


      7.  同时对父类和子类的同一个属性进行KVO监听会怎么样.
父类和子类同时存在KVO时（监听同一个对象的同一个属性）,很容易出现对同一个keyPath进行两次removeObserver操作，从而导致程序crash。 要避免这个问题，就需要区分出KVO是self注册的，还是superClass注册的，我们可以在 -addObserver:forKeyPath:options:context:和-removeObserver:forKeyPath:context。这两个方法中传入不同的context进行区分。
如果当前类无法捕捉kvo，有可能是父类中捕捉，所以，添加上[super observeValueForKeyPath:keyPath ofObject:object change:change context:context]; 准没错

      7.  KVO会对Observer进行强引用么. NSNotification的Observer会被强引用么.
kvo中被观察者不会对观察者进行强引用。
nsnotification中从 iOS 9 开始通知中心会对观察者进行弱引用，所以不需要在观察者对象释放之前从通知中心移除。
但是，通过-[NSNotificationCenter addObserverForName:object:queue:usingBlock]方法注册的观察者依然需要手动的释放，因为通知中心对它们持有的是强引用。
[NSNotificationCenter removeObserver]来移除

addObserver://不需要手动移除
addObserverForName//需要手动移除

      8.  在非UI线程Post Notification 会怎么样. 在非UI 线程 Add Notification会怎么样.
[NotificationCenter defaultCenter] postNotification]，这种方式是同步的，并且在哪个线程发，就在哪个线程收。
同步的意思，就是消息接收者全部处理完消息之后，post这方才会继续往下执行，因此，尽量不要做太耗时的操作。
由于消息收和发都在同一个线程中。所以，尽量在主线程中post，不然会引起不必要的麻烦，ui刷新问题，崩溃问题等等。

异步通知
异步的好处，不必等待所有的消息处理者处理完成，可以立马返回。
如果要发送异步通知，可以使用NSNotificationQueue，将通知enqueueNotification之后，会在合适的时候将通知发送给NotificationCenter，NotificationCenter会真正的将消息post出去。

mach port，它主要用来线程间通信。简单来说，就是接收线程中注册NSMachPort，在另外的线程中使用此port发送消息，则注册线程会收到相应消息，调用handleMachMessage来处理。

      9.  Notification响应的顺序能保证么. 有什么办法能保证执行顺序.
- (void)addObserver:(id)observer selector:(SEL)aSelector name:(nullable NSNotificationName)aName object:(nullable id)anObject;
aName 为空时接收所有类型的通知消息，但是确定不了接收这些消息的顺序。
anObject 不为空时 仅接收到anObject的所有通知消息
提醒一下观察者收到通知的顺序是没有定义的。同时通知发出和观察的对象有可能是一样的。
通知中心同步转发通知给观察者，就是说 postNotification: 方法直到接收并处理完通知才返回值。
要想异步的发送通知，可以使用NSNotificationQueue。在多线程编程中，通知一般是在一个发出通知的那个线程中转发，但也可能是不在同一个线程中转发通知。

      10. GCD在什么情况下需要考虑循环引用问题.
循环引用是因为  2个对象互相  强引用了  
控制器并没有强引用  block 吧  , 也没有强引用 block 的持有者 

      11. GCD Group 两种使用方法的区别.
dispatch_group_enter 
Calling this function indicates another block has joined the group through
a means other than dispatch_group_async(). Calls to this function must be
balanced with dispatch_group_leave().

      12. 主队列与主线程的区别.
 进程:正在进行中的程序被称为进程，负责程序运行的内存分配;每一个进程都有自己独立的虚拟内存空间
 线程:线程是进程中一个独立的执行路径(控制单元);一个进程中至少包含一条线程，即主线程
 队列 dispatch_queue_t，队列名称在调试时辅助，无论什么队列和任务，线程的创建和回收不需要程序员操作，有队列负责。
 主队列：每一个应用程序对应唯一一个主队列，直接GET即可；在多线程开发中，使用主队列更新UI
 　　　　　　　dispatch_queue_t q = dispatch_get_main_queue();
 主队列：  专门用来在主线程上调度任务的"队列"，主队列不能在其他线程中调度任务！

      13. 如何判断一个队列是主队列.
线程和队列
队列不是线程，队列时用来组织任务的，我们将任务添加到队列中，系统会根据资源决定是否创建新的线程去处理队列中的任务。线程的创建、维护和销毁由操作系统来管理。
// Object-C
static void *mainQueueKey = "mainQueueKey"; 
dispatch_queue_set_specific(dispatch_get_main_queue(), mainQueueKey, &mainQueueKey, NULL); 
if (dispatch_get_specific(mainQueueKey)) { 
    // do something in main queue 
} else { 
    // do something in other queue 
}

      14. GCD在什么情况下会新开线程.
并发队列 异步执行

      15. 能不能取消一个正在执行的异步任务.
一般情况下是不行，只有在任务执行过程中设置一些变量来取消。

      16. NSOperation什么时候从NSOperationQueue中移除.
当向一个queue中添加一个operation之后，我们不能直接将其从queue中移除。一个operation会一直在queue中，直到其汇报其task 结束(finish)。一个operation的任务结束并不意味着其任务完成，也可能是此operation被取消。

      17. 如何创建一个异步的NSOperation子类.
      【https://www.cnblogs.com/jiuzhou/p/5299535.html】
NSOperationQueue时iOS中常用的任务调度机制。在创建一个复杂任务的时候，我们通常都需要编写NSOperation的子类。在大部分情况下，重写main方法就可以满足要求。main方法执行完毕后，系统就会认为这个operation完成了。
有时候情况并没有这么简单。我们需要在operation中调用异步的API，这个API会通过一个block或者代理通知我们结果。这时只靠覆盖main方法就显得力不从心了。因为异步API尚未执行完毕，main方法并不会等待任务执行完毕，而是立即返回，系统就认为operation已经完成了。
怎么解决这个问题呢？我想到AFNetworking中有同样的案例，于是参考了其中的实现，设计了一个基于异步任务的operation。
我们需要覆盖start方法。这个方法的作用有点类似于main方法，在这里完成具体的任务。那么系统怎么知道我们的任务开始执行，或者完成了呢？系统会通过KVO的形式，监听operation的一些属性。我们可以重新实现这些属性，这样系统就可以监听operation执行的状态。
我们需要重新实现这些属性：
@property (readonly, getter=isReady) BOOL ready;
@property (readonly, getter=isExecuting) BOOL executing;
@property (readonly, getter=isFinished) BOOL finished;
它们都是只读属性。我们可以简单的重写它们，返回我们想要的值。但是，如何通知KVO系统它们的值发生了变化呢？
NSObject的这一对方法能够帮助我们，可以利用它们手动通知系统某个属性发生了变化。
- (void)willChangeValueForKey:(NSString *)key;
- (void)didChangeValueForKey:(NSString *)key;

      18.  NSThread的两种创建方式的区别. 
alloc init 
detachNewThreadWithBlock
方式一相对于后两种方式可以获得一个NSThread对象
通过线程对象可以直接对线程的状态进行操作


      19.  OC里面有深拷贝么. 如何深拷贝一个NSArray.
      【https://blog.csdn.net/liuyinghui523/article/details/79411652】
浅拷贝：仅仅对内存地址进行了拷贝，并没有对源对象进行拷贝。
深拷贝：不仅对内存地址进行拷贝，而且对源对象进行拷贝。
完全深拷贝：在拷贝的时候，被拷贝对象的每一层都进行了拷贝。

ns copy 浅拷贝 mutablecopy 深拷贝
nsmutable copy 深拷贝
多层集合对象的完全拷贝 
实现NSCoding,NSCopying协议

NSString 类型的copy 还是 strong
当name修饰符为copy时，得到的name是对myString的深拷贝对象，二者互不影响。
所以当给myString对象发送方法appendString的时候，修改的只是myString（此时的值为@“12345678”），而name依然不变@“1234”;
当name修饰符为strong时，name和myString指向同一对象，@"1234"的引用计数为2。
当修改myString时name也会一起变化。所以为了避免NSString类型的值被修改，一般建议用copy修饰符修饰。



      20.  如何并发的遍历一个数组.
enumerateObjectsWithOptions:usingBlock: 
typedef enum NSEnumerationOptions : NSUInteger {
    NSEnumerationConcurrent = (1UL << 0),
    NSEnumerationReverse = (1UL << 1)
} NSEnumerationOptions;

      21.  NSArray, NSDictionary字面量初始化方法如何防止崩溃.
找到调用的方法，再Category + runtime 的方式达到了降低crash的风险。

（https://blog.csdn.net/weixin_33737134/article/details/87358964）
@[]这种方式创建的数组是通过发送消息给NSArray执行arrayWithObjects:count:这个方法来创建的数组。

【https://blog.csdn.net/chenzuhuan478/article/details/80473769?utm_source=blogxgwz5】
Method Swizzling
根据 crash log，dictionary 主要有三个入口传入 nil object：
字面量初始化一个 dictionary 的时候，会调用 dictionaryWithObjects:forKeys:count:
直接调用 setObject:forKey 的时候 
通过下标方式赋值的时候，会调用 setObject:forKeyedSubscript:
所以可以通过 method swizzling，把这四个方法（还有 initWithObjects:forKeys:count:，虽然没有发现哪里有调用到它）替换成自己的方法，在 key 为 nil 的时候忽略，在 value 为 nil 的时候，替换为 NSNull 再插入。
其中 setObject:forKey 方法因为是通过 class cluster 实现的，所以实际替换的是 __NSDictionaryM 的方法。

      22. 自定义类的实例可以作为NSDictionary的Key么.
NSDictionary的键要求该对象类型实现NSCopying这个协议

      23. 集合类属性用atomic修饰能保证线程安全么.
property 的 atomic 是采用 spinlock_t 也就是俗称的自旋锁实现的。
atomic通过这种方法，在运行时保证 set,get方法的原子性。 
仅仅是保证了set,get方法的原子性。 

      24. 什么情况下使用Copy修饰.
NSArray、NSDictionary、NSString最好用copy来修饰
必须使用copy的情况是：
1.属性是一个不可变对象，如NSString,NSArray.
2.需要把一个可变对象赋值给属性，如上面代码中把NSMutableString赋值给NSString.
除此之外的情况，使用copy和strong是没区别的。

      25. 什么情况下需要使用@synthesize.
OS 6 之后 LLVM 编译器引入property autosynthesis，即属性自动合成。换句话说，就是编译器会为每个 @property 添加 @synthesize ，如以下形式：
@synthesize propertyName = _propertyName;
这行代码会创造一个带下划线前缀的实例变量名，同时使用这个属性生成getter 和 setter 方法。
使用@synthesize 只有一个目的——给实例变量起个别名，或者说为同一个变量添加两个名字。
如果要阻止自动合成，记得使用 @dynamic 。经典的使用场景是你知道已经在某处实现了getter/setter 方法，而编译器不知道的情况。
还有一种情形需要使用 @synthesize ，就是当在 protocol 中声明并实现属性时。协议中声明的属性不会自动生成setter和getter，[UIApplicationDelegate window] 就是个典型的例子。


      26. __block __weak的区别.
其实这个问题在现在来说主要就是2个区别：

block下循环引用的问题
__block本身并不能避免循环引用，避免循环引用需要在block内部把__block修饰的obj置为nil
__weak可以避免循环引用，但是其会导致外部对象释放了之后，block 内部也访问不到这个对象的问题，我们可以通过在 block 内部声明一个 __strong
的变量来指向 weakObj，使外部对象既能在 block 内部保持住，又能避免循环引用的问题
__block与__weak功能上的区别。
__block会持有该对象，即使超出了该对象的作用域，该对象还是会存在的，直到block对象从堆上销毁；而__weak仅仅是将该对象赋值给weak对象，当该对象销毁时，weak对象将指向nil；
__block可以让block修改局部变量，而__weak不能。
另外，MRC中__block是不会引起retain；但在ARC中__block则会引起retain。所以ARC中应该使用__weak。



      27. 分类与扩展什么区别.
虽然有人说extension是一个特殊的category，也有人将extension叫做匿名分类，但是其实两者差别很大。
extension
在编译器决议，是类的一部分，在编译器和头文件的@interface和实现文件里的@implement一起形成了一个完整的类。
伴随着类的产生而产生，也随着类的消失而消失。
extension一般用来隐藏类的私有消息，你必须有一个类的源码才能添加一个类的extension，所以对于系统一些类，如nsstring，就无法添加类扩展
category
是运行期决议的
类扩展可以添加实例变量，分类不能添加实例变量
原因：因为在运行期，对象的内存布局已经确定，如果添加实例变量会破坏类的内部布局，这对编译性语言是灾难性的。


      28. 如何调用到一个被分类覆盖了的实例方法.
Category里写了与主类同名的方法，按照Objc的消息机制调用，会调用了Category的，而主类的同名方法像是被覆盖了。
实际上，Category并没有覆盖主类的同名方法，只是Category的方法排在方法列表前面，而主类的方法被移到了方法列表的后面。 
于是，我们可以在Category方法里，利用Runtime提供的API，从方法列表里拿回原方法，从而调用。

      29. Method  Swizzling在什么情况下回无限循环.
看似错误的代码
- (void)swizzled_viewDidAppear:(BOOL)animated {
    [self swizzled_viewDidAppear:animated];
}

如上，这段代码，对于一个合格的工程师而言，应该会很警惕。正常情况下在类中调用，必然进入无限循环。然而，在Method Swizzling中，这样才是正确的用法。理解下其中的逻辑。在load方法中实现了Swizzling，系统SEL的viewDidAppear指向的是swizzled_viewDidAppear的实现，方法SEL名为swizzled_viewDidAppear指向的是系统名为viewDidAppear的实现。所以在调用过程中相当两个方法交叉调用了，并没有导致死循环。

      30. 如何 Swizzling 一个 类方法.
Method repMethod = class_getInstanceMethod(cls, rep);
Method class_getClassMethod(Class cls, SEL sel)
{
    if (!cls  ||  !sel) return nil;
    return class_getInstanceMethod(cls->getMeta(), sel);
}

instance => class => meta class

      31. 如何打印一个对象的堆地址和栈地址.

      32. [super init] super是谁.
self和super区别
区别:
- self调用自己方法，super调用父类方法
- self是类，super是预编译指令
- self class】和【super class】输出是一样的
符合oc 继承类 初始化规范 super 同样也是这样， [super init] 去self 的super 中调用init super 调用 superSuper 的init 。直到根类 NSObject 中的init ,根类中init 负责初始化 内存区域 向里面添加 一些必要的属性，返回内存指针， 这样 延着继承链 初始化的内存指针 被从上 到 下 传递，在不同的子类中向块内存添加 子类必要的属性，直到 我们的 A 类中 得到内存指针，赋值给slef 参数， 在if (slef){//添加A 的属性 }

      33. alloc init初始化与使用New初始化有区别么.

      34. 关联属性的存取策略里面为什么没有weak.
      [http://www.cocoachina.com/cms/wap.php?action=article&id=23710]
关联对象并不是存储在被关联对象本身内存中，而是存储在全局的统一的一个AssociationsManager中，如果设置关联对象为nil，就相当于是移除关联对象。

此时我们我们在回过头来看objc_AssociationPolicy policy 参数: 属性以什么形式保存的策略。

typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) {
    OBJC_ASSOCIATION_ASSIGN = 0,  // 指定一个弱引用相关联的对象
    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, // 指定相关对象的强引用，非原子性
    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,  // 指定相关的对象被复制，非原子性
    OBJC_ASSOCIATION_RETAIN = 01401,  // 指定相关对象的强引用，原子性
    OBJC_ASSOCIATION_COPY = 01403     // 指定相关的对象被复制，原子性   
};
我们会发现其中只有RETAIN和COPY而为什么没有weak呢？

总过上面对源码的分析我们知道，object经过DISGUISE函数被转化为了disguised_ptr_t类型的disguised_object。

disguised_ptr_t disguised_object = DISGUISE(object);
而同时我们知道，weak修饰的属性，当没有拥有对象之后就会被销毁，并且指针置位nil，那么在对象销毁之后，虽然在map中既然存在值object对应的AssociationsHashMap，但是因为object地址已经被置位nil，会造成坏地址访问而无法根据object对象的地址转化为disguised_object了。


      35. 等等

    c）iOS 基础
      1.  Autolayout计算Frame(或者说计算坐标)的过程.
约束是通过 线性等式 和 线性不等式 的算法来计算，视图越复杂，计算难度越大，耗时越多。      

      2.  如何判断一个UIView是View Controller的Root View.
1.什么时候被调用？
每次访问UIViewController的view(比如controller.view、self.view)而且view为nil，loadView方法就会被调用。
2.有什么作用？
loadView方法是用来负责创建UIViewController的view。
3.默认实现是怎样的？
默认实现即[super loadView]里面做了什么事情。
（1）它会先去查找与UIViewController相关联的xib文件，通过加载xib文件来创建UIViewController的view
（2）如果没有找到相关联的xib文件，就会创建一个空白的UIView，然后赋值给UIViewController的view属性


      3.  如何显示一个UIWindow的或其子类.
//3. 显示窗口
[testWindow makeKeyAndVisible];

UIWindow介绍
　　1、作为容器，包含app所要显示的所有视图
　　3、与UIViewController协同工作，方便完成设备方向旋转的支持
　　1、addSubview
　　2、rootViewController
三、WindowLevel
keyWindow是被系统设计用来接受键盘和其他非触摸事件的UIWindow。我们可以 通过makeKeyWindow 和 resignKeyWindow 方法来将自己创建的UIWindow实例设置成keyWindow。

      4.  CAShapeLayer与其他的CALayer有什么区别.
      CAShapeLayer  是 CALayer的子类
普通CALayer在被初始化时是需要给一个frame值的,这个frame值一般都与给定view的bounds值一致,它本身是有形状的,而且是矩形.
CAShapeLayer在初始化时也需要给一个frame值,但是,它本身没有形状,它的形状来源于你给定的一个path,然后它去取CGPath值,它与CALayer有着很大的区别
CAShapeLayer有着几点很重要:

它依附于一个给定的path,必须给与path,而且,即使path不完整也会自动首尾相接
strokeStart以及strokeEnd代表着在这个path中所占用的百分比
CAShapeLayer动画仅仅限于沿着边缘的动画效果,它实现不了填充效果

作者：coder_hong
链接：https://www.jianshu.com/p/cff469e39471
来源：简书
简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。

      5.  UIView/UIImageView的渲染过程.？？？？
VC的生命周期的部分过程
viewDidLoad -> viewWillAppear -> updateViewConstraints -> viewWillLayoutSubviews -> viewDidLayoutSubviews -> viewDidAppear -> viewWillDisAppear -> updateViewConstraints -> viewDidDisAppear

作者：我有小尾巴快看
链接：https://www.jianshu.com/p/6f8304397c2a
来源：简书
简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。

      6.  通过imageNamed加载的UIImage, 什么时候被释放.

      7.  给UIButton添加UITapGestureRecognizer哪个selector先相应.给UIButton的supperView添加Tap手势会怎么样.

      8.  GestureRecognizer与响应链什么关系.

      9.  rowHeight与回调的heightForRowAtIndexPath方法有什么区别.

     10. 如何解决手势冲突.
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch 


     11. 如何让UIView处理事件的同时继续传递事件.

事件逐级传递
如果想让响应者链中，每一级UIResponder都可以响应事件，可以在每级UIResponder中都实现touches并调用super方法，即可实现响应者链事件逐级传递。

-(BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch
- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event{

     12. NSMethod， SEL，IMP ， NSInvocation区别与联系.
SEL : 类成员方法的指针，但不同于C语言中的函数指针，函数指针直接保存了方法的地址，但SEL只是方法编号。
IMP:一个函数指针,保存了方法的地址
NSInvocation
NSInvocation是一个消息调用类，主要作用是存储和传递消息。它存储的信息包含了一个iOS消息全部的成分：target、selector、参数、返回值、方法签名。
也就是说，NSInvocation可以将传统的iOS消息发送这个过程转换成一个对象，然后执行这个对象的发送消息的方法就可以达到performSelector的效果，NSInvocation对象包含的每一个组成部分能够直接设定（如消息target，参数之类的）。
NSMethodSignature
方法签名 NSMethodSignature 是一个方法的返回类型和参数类型，不包括方法名称。
NSMethodSignature *signature = [NSMethodSignature signatureWithObjCTypes:"@@:*"];
其中字符串@@:*
@表示返回值为id
@:表示方法target和sel，iOS的每个方法都有这两个隐藏参数
*表示一个char*类型的参数

在iOS开发中，直接调用方法的方式有以下两种：
(id)performSelector:(SEL)aSelector
使用NSInvocation对象
从官方的说明可以看到，这种方式比较局限，例如只能最多传递两个参数，超过两个参数的话，官方建议使用NSInvocation对象来实现方法的直接调用。使用NSInvocation可以更加方便地更改方法调用的参数，包含直接调用iOS的私有方法，更改参数值等。

作者：conowen
链接：https://www.jianshu.com/p/48244c176f1c
来源：简书
简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。

     13. id 与 NSObject *有什么区别.
id void * 被成为万能指针,也就是可以指向任何对象.
NSObject * 本身就是定义指向NSObject类型的指针.
那么这两者有什么区别吗?
这两者都是既可以作为返回值,又可以作为变量修饰.而其主要区别则在于id修饰的变量不遵循<NSObject>协议.
这在实现代理模式中会体现出其区别,例如在调用代理方法时会先判断该代理是否能够响应某个方法  
[obj respondsToSelector:]就定义在NSObject协议中. 

     14. layoutSubviews什么时候被触发.
layoutSubviews在以下情况下会被调用：
1、init初始化不会触发layoutSubviews
2、addSubview会触发layoutSubviews
3、设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化
4、滚动一个UIScrollView会触发layoutSubviews
5、旋转Screen会触发父UIView上的layoutSubviews事件
6、改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件



     15. Quartz2D，CoreAnimation，CoreGraphics的区别与联系.
CoreGraphics(核心图形)       它是iOS的核心图形库，包含Quartz2D绘图API接口,常用的是point，size，rect等这些图形，都定义在这个框架中，类名以CG开头的都属于CoreGraphics框架，它提供的都是C语言函数接口，是可以在iOS和mac OS 通用的。
CoreGraphics是底层绘制框架，我们实际会用到的也就是CG开头的一些底层绘制函数和变量，这是一个纯C语言框架。
QuartzCore(包含CoreAnimation）框架，是iOS系统的基本渲染框架，是一个OC语言框架，是一套基于CoreGraphics的OC语言封装，封装出了基本渲染类CALayer

作者：骑着毛驴走起来
链接：https://www.jianshu.com/p/8ebc0df474e9
来源：简书
简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。

     16.  如何绘制 1 pixel的竖线.
     [https://www.cnblogs.com/v2m_/p/6288240.html]
     [https://www.cnblogs.com/smileEvday/p/iOS_PixelVsPoint.html]
一像素的线宽 是 1.0 / [UIScreen mainScreen].scale

像素对齐

Path中 stroke是根据线（line）的位置，向两边各扩散 一半的线宽，所以绘制方法是：使用Path的 moveToPoint 和 addLineToPoint 方法添加一根1 pixel线，然后偏移 目标位置 +0.5 pixel（对应到point 就是 1.0 / [UIScreen mainScreen].scale ／ 2.0）。
Path 中 fill 是直接填充框内区域，所以设置好 1 pixel 的区域后，不需要相对目标位置设置偏移。
对比下下面两段代码，都是画在第一列 pixel 的
float u = 1.0 / [UIScreen mainScreen].scale;
```
UIBezierPath* path = [UIBezierPath bezierPath];
[path moveToPoint:CGPointMake(u / 2.0, 0)];
[path addLineToPoint:CGPointMake(u / 2.0, 50)];
path.lineWidth = u;
[[UIColor blackColor] set];
[path stroke];
float u = 1.0 / [UIScreen mainScreen].scale;
```
```
UIBezierPath* path = [UIBezierPath bezierPathWithRect:CGRectMake(0, 0, u, 50)];
[[UIColor blackColor] set];
[path fill];
```

      17. 如何自己实现一个ContainerViewController.
为了实现容易类视图控制器，你必须建立容器类视图控制器与子视图控制器的父子关系。在你即将要管理这些子视图控制器的view的之前必须构建好这些父子关系。这样可以让UIKit知道你正在管理的子视图控制器的视图的位置和大小，你可以通过interface builder或者代码进行构建这些关系。当你使用代码创建这些父子关系的时候，你可以准确的增加或者移除子视图控制器。
为了能够通过代码将子视图控制器添加到容器类视图控制器中，如下步骤可以创建父子关系：
1.调用容器视图控制器 addChildViewController: 的方法，这个方法用来告诉UIKit你的容器类视图控制器即将要管理一个子视图控制器。
2.增加子视图控制器的view到 容器视图控制的view（或者Container View）的视图层级结构中，千万别忘记设置大小的位置。
3.为管理子视图控制的view的大小和位置添加约束条件。
4.调用子视图控制的 didMoveToParentViewController: 方法。
- (void) displayContentController: (UIViewController*) content { 
    [self addChildViewController:content]; 
    content.view.frame = [self frameForContentController]; 
    [self.view addSubview:self.currentClientView]; 
    [content didMoveToParentViewController:self]; 
}
为了移除一个子视图控制器，移除父子关系必须遵循以下步骤：

1.调用子视图的 willMoveToParentViewController: 方法 参数为nil
2.移除任何你对子视图控制的view的约束条件
3.将子视图控制的view从容器类视图控制器的层级结构中移除
4.调用子视图控制器的 removeFromParentViewController 方法 从而最终结束父子关系
- (void) hideContentController: (UIViewController*) content { 
    [content willMoveToParentViewController:nil]; 
    [content.view removeFromSuperview]; 
    [content removeFromParentViewController]; 
}

https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/ImplementingaContainerViewController.html#//apple_ref/doc/uid/TP40007457-CH11-SW1

作者：Neo_joke
链接：https://www.jianshu.com/p/68a589e244e4
来源：简书
简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。

      18. NSCache与NSDictionary有什么区别.
NSCache 是一个容器类，类似于NSDIctionary,通过key-value 形式存储和查询值，用于临时存储对象。
注意一点它和NSDictionary区别就是，NSCache 中的key不必实现copy，NSDictionary中的key必须实现copy
NSCache中存储的对象也不必实现NSCoding协议，因为毕竟是临时存储，类似于内存缓存，程序退出后就被释放了。

NScache是线程安全的，在多线程操作中，不需要对Cache加锁。NSCache在系统内存很低时，会自动释放一些对象。
NScache的key只是做强引用，不需要实现NScopying协议。
--------------------- 
作者：bowei-iOS 
来源：CSDN 
原文：https://blog.csdn.net/bowei1105/article/details/73320997 
版权声明：本文为博主原创文章，转载请附上博文链接！

      19. 如何停止一个Runloop.
如果不想退出runloop可以使用第一种方式启动runloop；
使用第二种方式启动runloop，可以通过设置超时时间来退出；
使用第三种方式启动runloop，可以通过设置超时时间或者使用CFRunLoopStop方法来退出。

      20. 一个线程里面可以有多少个Runloop.
runloop和线程有什么关系？
每条线程都有唯一的一个RunLoop对象与之对应的
主线程的RunLoop是自动创建并启动
子线程的RunLoop需要手动启动

      21. Runloop的三个run 方法什么区别与联系.
启动一个runloop有以下三种方法：
- (void)run;  
- (void)runUntilDate:(NSDate *)limitDate；
- (void)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate;
这三种方式无论通过哪一种方式启动runloop，如果没有一个输入源或者timer附加于runloop上，runloop就会立刻退出。
(1) 第一种方式，runloop会一直运行下去，在此期间会处理来自输入源的数据，并且会在NSDefaultRunLoopMode模式下重复调用runMode:beforeDate:方法；
(2) 第二种方式，可以设置超时时间，在超时时间到达之前，runloop会一直运行，在此期间runloop会处理来自输入源的数据，并且也会在NSDefaultRunLoopMode模式下重复调用runMode:beforeDate:方法；
(3) 第三种方式，runloop会运行一次，超时时间到达或者第一个input source被处理，则runloop就会退出。
前两种启动方式会重复调用runMode:beforeDate:方法。

作者：GabrielPanda
链接：https://www.jianshu.com/p/24f875775336
来源：简书
简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。

      26. iOS 系统在哪些地方用到了Runloop.

      27. 工程的Info.plist文件什么时候被解析的.
深入解析Mac OS X & iOS操作系统2.6.1 Info.plist
Info.plist文件位于应用程序(以及其他大部分bundle)的Contents/子目录下，这个文件保存了bundle的元数据信息。这个文件是必备的，操作系统通过这个文件判定依赖关系和其他属性。

      28. 如何获取一个对象的内存大小.
sizeOf([NSObject class])该运算符为编译时,就可以获取大小,类似于宏定义
class_getInstanceSize函数,则要在运行时获取

    d）其他
       1. MVC, MVVM等架构模式的理解.

       2. 设计模式的理解.

       3. 看过哪些开源框架，有什么收获.

       4. Instruments的使用.

       5. 做过哪些优化方面的工作.

       7. 常用的一个Git 命令.

       8. Cocoapods的使用.

       9. 等等.